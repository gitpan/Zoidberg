# grammar bevat regex => denk om escape codes => escape alles wat ook maar een beetje vaag is
# ('>>', '>') goed -- ('>', '>>') fout -- regex neemt de eerste die matched -- kan dit enge bugs opleveren ?
# wat about '>[^>]' ? -- be carefull

my $ps = chr(30);

$VAR1 = {
	'logic_or' => ['\|\|', 'OR', 'AUX'],
	'logic_and' => ['\&\&', 'AND', 'KAJ'],
	'end_of_statement' => [';', 'EOS', 'FIN'],
	'pound_sign' => $ps,
	'ansi_colors' => [qw/
		clear rest bold underline underscore blink
		black red green yellow blue magenta cyan white
		on_black on_red on_green on_yellow on_blue
		on_magenta on_cyan on_white
	/],
	# perl functions copied from perlfunc (perl version 5.8)
	'perl_functions' => [qw/
	abs accept alarm atan2
	bind binmode bless
	caller chdir chmod chomp chop chown chr chroot close closedir connect continue cos crypt
	dbmclose dbmopen defined delete die do dump
	each endgrent endhostent endnetent endprotoent endpwent endservent eof eval exec exists exit exp
	fcntl fileno flock fork format formline
	getc getgrent getgrgid getgrnam gethostbyaddr gethostbyname gethostent getlogin getnetbyaddr getnetbyname getnetent getpeername getpgrp getppid getpriority getprotobyname getprotobynumber getprotoent getpwent getpwnam getpwuid getservbyname getservbyport getservent getsockname getsockopt glob gmtime goto grep
	hex
	import index int ioctl
	join
	keys kill
	last lc lcfirst length link listen local localtime lock log lstat
	m map mkdir msgctl msgget msgrcv msgsnd my
	next no
	oct open opendir ord our
	pack package pipe pop pos print printf prototype push
	q qq qr quotemeta qw qx
	rand read readdir readline readlink readpipe recv redo ref rename require reset return reverse rewinddir rindex rmdir
	s scalar seek seekdir select semctl semget semop send setgrent sethostent setnetent setpgrp setpriority setprotoent setpwent setservent setsockopt shift shmctl shmget shmread shmwrite shutdown sin sleep socket socketpair sort splice split sprintf sqrt srand stat study sub substr symlink syscall sysopen sysread sysseek system syswrite
	tell telldir tie tied time times tr truncate
	uc ucfirst umask undef unlink unpack unshift untie use utime
	values vec
	wait waitpid wantarray warn write
	y
	/],
	'aliases' => [
		# [regex, replacement] ^\s*regex assumed
		['\!', ''],
		['\"', 'echo '],
		['\.(?!\S)', '_source '],
		['quit(?!\S)', "_quit "],
		['bye(?!\S)', "_quit \"Bye bye.\" "],
		['exit(?!\S)', "_quit \"Exiting ...\" "],
		['exec(?!\S)', "_exec "],
		['cd(?!\S)', "_cd "],
		['chdir(?!\S)', "_cd "],
		['back(?!\S)', "_back "],
		['forw(?!\S)', "_forw "],
		['up(?!\S)', "_cd .. "],
		['help(?!\S)', "? "],
		['print(?!\S)', "_print "],
		['cprint(?!\S)', "__print "], # to test this type of alias
		['export(?!\S)', "_set_env "],
		['source(?!\S)', "_source "],
		['ls(?!\S)', "ls --color=auto "],
	],
	'context' => {
		# 'NAME' => [parse_sub, intel_sub, ]
		'COMMAND' =>	['Commands->parse',	'Commands->intel'],
		'HELP' =>	['Help->help',		'Help->intel'],
		'NOTE' =>	['dev_null'],
		'SQL'  =>	['Hermes->parse',	'Hermes->intel'],
		'C'    =>	['Sepository->parse'],
	},
	'script_gram' => {
		'nests' => [
			['\(', '\)', 'JOIN'],
			['\{', '\}', 'JOIN'],
			['\s\"', '\"(\s|$)', 'JOIN'],
			['\s\'', '\'(\s|$)', 'JOIN'],
		],
		# limits are autogenerated
		'limits' => [],
		'escape' => '\\\\', #'
	},
	'pipe_gram' => {
		'use_aliases' => 1,
		'default_context' => 'SYSTEM',
		'nests' => [
			['\(', '\)', 'JOIN'],
			['\{', '\}', 'JOIN'],
			['\s\"', '\"(\s|$)', 'JOIN'],
			['\s\'', '\'(\s|$)', 'JOIN'],
		],
		'limits' => ['\|', '>>', '<<', '(?<!-)>', '<', ';', '\&\&', '\|\|'],
		'escape' => '\\\\', #'
		'rules' => [
			['^\s*#', 'NOTE'],
			['^\s*\?', 'HELP', '$block->[0] =~ s/^\s*\?\s*//;'],
			['^\s*_', 'COMMAND', '$block->[0] =~ s/^\s*_\s*//;'],
			['^\s*(\w+)\{(.+)\}(\w*)\s*$', 'stub', '$block->[0] = $2; $block->[2] = uc($1); $block->[3] = $3'],
			['^\s*\{(.+)\}(\w*)\s*$', 'PERL', '$block->[0] = $1; $block->[3] = $2;'],
			["${ps}(?!_)", 'ZOID'],
			['^\s*(?i:select|insert|update|drop|alter|delete|show|use)','SQL'],
			['->', 'ZOID'],
			["^\\s*${ps}_", 'ZOID'],
			['^\s*[\$\@\%]', 'PERL'],
			['^\s*c\/','C'],
		],
		'broken_rules' => [
			['^\s*(\w+)\{(.*)', 'stub', '$block->[0] = $2; $block->[2] = uc($1);'],
			['^\s*\{(.*)', 'PERL', '$block->[0] = $1;'],
			["${ps}(?!_)", 'ZOID'],
			['^\s*(?i:select|insert|update|drop|alter|delete|show|use)','SQL'],
			['->', 'ZOID'],
			["^\\s*${ps}_", 'ZOID'],
			['^\s*[\$\@\%]', 'PERL'],
			['^\s*c\/','C'],
		],
	},
	'eval_zoid_gram' => {
		'nests' => [
			['\"', '\"', 'JOIN'],
			['\'', '\'', 'JOIN'],
		],
		'limits' => ["((?<![\\w\\}\\)\\]])->|${ps})([\\{]?\\w+[\\}]?)", "${ps}_"],
		'escape' => '\\\\', #'
	},
	'space_gram' => {
		'nests' => [
			['\(', '\)', 'JOIN'],
			['\{', '\}', 'JOIN'],
			['\"', '\"'],
			['\'', '\''],
		],
		'limits' => ['\s+'],
		'escape' => '\\\\',
		'pre_rules_code' => '	@{$self->{tree}} = grep {$_->[0] || ($_->[1] =~ /^(BROKEN|END)$/)} @{$self->{tree}};
					unless (@{$self->{tree}}) { @{$self->{tree}} = (["", "", ""]); }',
	},
	'syntax' => { # syntax highlighting grammars
		'PERL' => {
			'nests' => [
				['\"', '\"', 'yellow'],
				['\'', '\'', 'yellow'],
			],
			'limits' => [';', '\s+', '/', '\)', '\(', '\{', '\}', '\[', '\]'],
			'escape' => '\\\\', #'
			'rules' => [
				['^[\$\@\%]', 'green'],
			],
			'colors' => {
				'cyan' => [qw/my our local sub/],
				'red' => [qw/__END__ __FILE__ \\WINC \\W?ISA \\WARGV STDIN STDOUT STDERR DESTROY/],
			},
		},
		'SQL' => {
			'nests' => [
				['\"', '\"', 'yellow'],
				['\'', '\'', 'yellow'],
			],
			'limits' => [';', '\s+', '/', '\)', '\(', '\{', '\}', '\[', '\]'],
			'escape' => '\\\\', #'
			'rules' => [],
			'colors' => {
				'green' => [qw/?i:select insert update drop alter delete show use create grant/],
				'red' => [qw/?i:from where order group like by asc desc all privileges identified/],
			},
		},
		'NOTE' => { 'default_color' => 'yellow', },
        'C' => {
            'default_color' => 'on_red',
        },
	},
};
# perform some linking

# for highlighting
$VAR1->{syntax}{PERL}{colors}{underline} = $VAR1->{perl_functions};

# for script
for (qw/logic_or logic_and end_of_statement/) {
	push @{$VAR1->{script_gram}{limits}}, @{$VAR1->{$_}};
}

# return value
$VAR1;
