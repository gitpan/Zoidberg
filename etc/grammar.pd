# grammar bevat regex => denk om escape codes => escape alles wat ook maar een beetje vaag is
# ('>>', '>') goed -- ('>', '>>') fout -- regex neemt de eerste die matched -- kan dit enge bugs opleveren ?
# wat about '>[^>]' ? -- be carefull

$VAR1 = {
	'logic_or' => ['\|\|', 'OR', 'AUX'],
	'logic_and' => ['\&\&', 'AND', 'KAJ'],
	'end_of_statement' => [';', 'EOS', 'FIN'],
	'ansi_colors' => [qw/
		clear rest bold underline underscore blink
		black red green yellow blue magenta cyan white
		on_black on_red on_green on_yellow on_blue
		on_magenta on_cyan on_white
	/],
	'perl_functions' => [qw/
		abs  accept  alarm  and  atan2
		bind binmode bless caller chdir chmod chomp
		chop chr chroot close closedir cmp connect  continue
		cos  crypt  dbmclose  dbmopen defined  delete  die
		do  dump  each  else  elsif
		eof  eq  eval  eval  exec  exists  exit  exp  fcntl
		fileno  flock  for  foreach  fork  formline
		ge  getc  getlogin  getpeername  getpgrp  getppid
		getpriority  getsockname  getsockopt  glob  gmtime
		goto  goto  grep  gt  hex  if  import
		index  int  ioctl
		join  keys  kill  last  lc  lcfirst  le  length  link
		listen  local  localtime  log   lstat  lt  m  map
		mkdir my  ne  next  no  npt oct
		open  opendir  or  ord
		pack  package  pipe
		pop  pos  print  printf  push  quotemeta  rand  read  readdir
		readlink  recv  redo  ref  rename  require
		reset  return  reverse  rewindir  rindex  rmdir s  scalar
		scalar  seek  seekdir  select  send  setpgrp  setpriority  setsockopt
		shift  shutdown  sin  sleep  socket  socketpair  sort
		splice  split  sprintf  sqrt  srand  stat
		study  sub  substr  symlink  syscall  sysread  system
		syswrite  tell  telldir  tie  time  times
		tr  truncate  uc  ucfirst  umask  undef  unless
		unlink  unpack  unshift  untie  until  until
		utime use values  vec  wait  waitpid
		wantarray  warn while write xor y
	/],
	'aliases' => [
		# [regex, replacement] ^\s*regex assumed
		['\!', ''],
		['\"', 'echo '],
		['\.(?!\S)', '_source '],
		['quit(?!\S)', "_quit "],
		['bye(?!\S)', "_quit \"Bye bye.\" "],
		['exit(?!\S)', "_quit \"Exiting ...\" "],
		['exec(?!\S)', "_exec "],
		['cd(?!\S)', "_cd "],
		['chdir(?!\S)', "_cd "],
		['back(?!\S)', "_back "],
		['forw(?!\S)', "_forw "],
		['help(?!\S)', "? "],
		['print(?!\S)', "_print "],
		['cprint(?!\S)', "__print "], # to test this type of alias
		['export(?!\S)', "_set_env "],
		['source(?!\S)', "_source "],
		['ls(?!\S)', "ls --color=auto "],
		['dir(?!\S).*', '_echo "This aint a DOS box !   (i hope) "'],
	],
	'context' => {
		# 'NAME' => [parse_sub, intel_sub, ]
		'COMMAND' =>	['Commands->parse',	'Commands->intel'],
		'HELP' =>	['Help->help',		'Help->intel'],
		'NOTE' =>	['dev_null'],
		'SQL'  =>	['Hermes->parse', 'Hermes->intel'],
		'C'    =>	['Sepository->parse'],
	},
	'script_gram' => {
		'nests' => [
			['\(', '\)', 'JOIN'],
			['\{', '\}', 'JOIN'],
			['\s\"', '\"(\s|$)', 'JOIN'],
			['\s\'', '\'(\s|$)', 'JOIN'],
		],
		# limits are autogenerated
		'limits' => [],
		'escape' => '\\\\', #'
	},
	'pipe_gram' => {
		'use_aliases' => 1,
		'default_context' => 'SYSTEM',
		'nests' => [
			['\(', '\)', 'JOIN'],
			['\{', '\}', 'JOIN'],
			['\s\"', '\"(\s|$)', 'JOIN'],
			['\s\'', '\'(\s|$)', 'JOIN'],
		],
		'limits' => ['\|', '>>', '<<', '(?<!-)>', '<', ';', '\&\&', '\|\|'],
		'escape' => '\\\\', #'
		'rules' => [
			['^\s*#', 'NOTE'],
			['^\s*\?', 'HELP', '$block->[0] =~ s/^\s*\?\s*//;'],
			['^\s*_', 'COMMAND', '$block->[0] =~ s/^\s*_\s*//;'],
			['^\s*(\w+)\{(.+)\}\s*$', 'stub', '$block->[0] = $2; $block->[2] = uc($1);'],
			['^\s*\{(.+)\}\s*$', 'PERL', '$block->[0] = $1;'],
			['\\x1E(?!_)', 'ZOID'],
			['->', 'ZOID'],
			['^\s*\\x1E_', 'ZOID'],
			['^\s*\$', 'PERL'],
			['^\s*(?i:select|insert|update|drop|alter|delete|show|use)','SQL'],
			['(?i)^\s*sql\:','SQL','$block->[0] =~ s/(?i)^\s*sql\://;'],
            		['^\s*c\/','C'],
		],
		'broken_rules' => [
			['^\s*\{', 'PERL'],
			['^\s*(?i:select|insert|update|drop|alter|delete|show|use)','SQL'],
            ['^\s*c\/','C'],
		],
	},
	'eval_zoid_gram' => {
		'nests' => [
			['\"', '\"', 'JOIN'],
			['\'', '\'', 'JOIN'],
		],
		'limits' => ['((?<![\w\}\)\]])->|\\x1E)([\{]?\w+[\}]?)', '\\x1E_'],
		'escape' => '\\\\', #'
	},
	'space_gram' => {
		'nests' => [
			['\(', '\)', 'JOIN'],
			['\{', '\}', 'JOIN'],
			['\"', '\"'],
			['\'', '\''],
		],
		'limits' => ['\s+'],
		'escape' => '\\\\',
		'pre_rules_code' => '	@{$self->{tree}} = grep {$_->[0] || ($_->[1] =~ /^(BROKEN|END)$/)} @{$self->{tree}};
					unless (@{$self->{tree}}) { @{$self->{tree}} = (["", "", ""]); }',
	},
	'syntax' => { # syntax highlighting grammars
		'PERL' => {
			'nests' => [
				['\"', '\"', 'yellow'],
				['\'', '\'', 'yellow'],
			],
			'limits' => [';', '\s+', '/', '\)', '\(', '\{', '\}', '\[', '\]'],
			'escape' => '\\\\', #'
			'rules' => [
				['^[\$\@\%]', 'green'],
			],
			'colors' => {
				'cyan' => [qw/my our local sub/],
				'red' => [qw/__END__ __FILE__ \\WINC \\W?ISA \\WARGV STDIN STDOUT STDERR DESTROY/],
			},
		},
		'SQL' => {
			'nests' => [
				['\"', '\"', 'yellow'],
				['\'', '\'', 'yellow'],
			],
			'limits' => [';', '\s+', '/', '\)', '\(', '\{', '\}', '\[', '\]'],
			'escape' => '\\\\', #'
			'rules' => [],
			'colors' => {
				'green' => [qw/?i:select insert update drop alter delete show use create grant/],
				'red' => [qw/?i:from where order group like by asc desc all privileges identified/],
			},
		},
		'NOTE' => { 'default_color' => 'yellow', },
        'C' => {
            'default_color' => 'on_red',
        },
	},
};
# perform some linking

# for highlighting
$VAR1->{syntax}{PERL}{colors}{underline} = $VAR1->{perl_functions};

# for script
for (qw/logic_or logic_and end_of_statement/) {
	push @{$VAR1->{script_gram}{limits}}, @{$VAR1->{$_}};
}
$VAR1;
